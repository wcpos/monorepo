name: Deploy

on:
  workflow_dispatch:
    inputs:
      target:
        description: Deploy as preview or production
        type: choice
        required: true
        default: preview
        options:
          - preview
          - production
      skip_e2e:
        description: Skip E2E tests
        type: boolean
        default: false
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

env:
  EXPO_USE_FAST_RESOLVER: true

jobs:
  deploy:
    name: üöÄ Deploy
    runs-on: ubuntu-latest
    outputs:
      deployment_url: ${{ steps.get-url.outputs.url }}
      is_production: ${{ steps.get-url.outputs.is_production }}
    steps:
      - name: üèó Setup repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: üèó Setup monorepo
        uses: ./.github/actions/setup-monorepo
        with:
          expo-token: ${{ secrets.EXPO_TOKEN }}
          rxdb-license-key: ${{ secrets.RXDB_LICENSE_KEY }}
          uniwind-auth-token: ${{ secrets.UNIWIND_AUTH_TOKEN }}

      - name: ‚úÖ Build apps/main
        run: pnpm run -w build:main

      - name: üåê Export apps/main for web
        working-directory: apps/main
        run: pnpm expo export --platform web --output-dir ./build

      - name: üöÄ Deploy preview
        id: deploy-preview
        if: github.event_name == 'pull_request' || github.event.inputs.target == 'preview'
        working-directory: apps/main
        run: |
          # Deploy and capture output
          set +e
          OUTPUT=$(eas deploy --export-dir ./build --non-interactive --json 2>&1)
          EXIT_CODE=$?
          set -e
          
          echo "EAS output: $OUTPUT"
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "::warning::EAS deploy exited with code $EXIT_CODE"
          fi
          
          # Extract URL from JSON output
          URL=$(echo "$OUTPUT" | grep -E '^\{' -A 100 | jq -r '.url // empty' 2>/dev/null || echo "")
          if [ -z "$URL" ]; then
            URL=$(echo "$OUTPUT" | grep -oE 'https://wcpos[a-zA-Z0-9._-]+\.expo\.app' | head -1 | tr -d '"' || echo "")
          fi
          
          # Fail if deployment failed AND no URL was extracted
          if [ $EXIT_CODE -ne 0 ] && [ -z "$URL" ]; then
            echo "::error::Deployment failed and no URL was extracted"
            exit 1
          fi
          
          echo "Deployment URL: $URL"
          echo "preview_url=$URL" >> $GITHUB_OUTPUT

      - name: üöÄ Deploy production
        id: deploy-production
        if: (github.event_name == 'push' && github.ref_name == 'main') || github.event.inputs.target == 'production'
        working-directory: apps/main
        run: |
          eas deploy --export-dir ./build --production
          echo "production_url=https://wcpos.expo.app" >> $GITHUB_OUTPUT

      - name: üìù Get deployment URL
        id: get-url
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ] || [ "${{ github.event.inputs.target }}" = "preview" ]; then
            echo "url=${{ steps.deploy-preview.outputs.preview_url }}" >> $GITHUB_OUTPUT
            echo "is_production=false" >> $GITHUB_OUTPUT
          else
            echo "url=https://wcpos.expo.app" >> $GITHUB_OUTPUT
            echo "is_production=true" >> $GITHUB_OUTPUT
          fi

  e2e:
    name: üé≠ E2E Tests (${{ matrix.shardIndex }}/${{ matrix.shardTotal }})
    needs: deploy
    if: needs.deploy.outputs.deployment_url != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_e2e != 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2, 3, 4, 5, 6]
        shardTotal: [6]
    steps:
      - name: üèó Setup repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: üèó Setup monorepo
        uses: ./.github/actions/setup-monorepo
        with:
          expo-token: ${{ secrets.EXPO_TOKEN }}
          rxdb-license-key: ${{ secrets.RXDB_LICENSE_KEY }}
          uniwind-auth-token: ${{ secrets.UNIWIND_AUTH_TOKEN }}

      - name: üé≠ Install Playwright browsers
        run: cd apps/main && npx playwright install --with-deps chromium

      - name: üè• Health check deployment
        run: |
          URL="${{ needs.deploy.outputs.deployment_url }}"
          echo "Checking deployment at: $URL"

          for i in {1..30}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || echo "000")
            echo "Attempt $i: HTTP $HTTP_CODE"

            if [ "$HTTP_CODE" = "200" ]; then
              # Verify the response contains expected app content
              BODY=$(curl -s "$URL")
              if echo "$BODY" | grep -q "WooCommerce POS\|wcpos\|expo"; then
                echo "‚úÖ Deployment is healthy and serving the app"
                exit 0
              else
                echo "‚ö†Ô∏è Got 200 but content doesn't look like the app, retrying..."
              fi
            fi

            sleep 10
          done

          echo "‚ùå Deployment health check failed after 30 attempts"
          exit 1

      - name: üß™ Run E2E tests (shard ${{ matrix.shardIndex }}/${{ matrix.shardTotal }})
        id: e2e-tests
        run: cd apps/main && npx playwright test --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}
        env:
          BASE_URL: ${{ needs.deploy.outputs.deployment_url }}
          CI: true

      - name: üìä Upload blob report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: blob-report-${{ matrix.shardIndex }}
          path: apps/main/blob-report/
          retention-days: 7

      - name: üì∏ Upload screenshots on failure
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-screenshots-${{ matrix.shardIndex }}-${{ github.sha }}
          path: apps/main/test-results/
          retention-days: 7

  e2e-report:
    name: üìä Merge E2E Reports
    needs: [deploy, e2e]
    if: always() && needs.e2e.result != 'skipped'
    runs-on: ubuntu-latest
    outputs:
      result: ${{ needs.e2e.result }}
    steps:
      - name: üèó Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20.x

      - name: üì• Download blob reports
        uses: actions/download-artifact@v4
        with:
          pattern: blob-report-*
          path: all-blob-reports
          merge-multiple: true

      - name: üìä Merge reports
        run: npx playwright merge-reports --reporter=html,json ./all-blob-reports
        env:
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: üìä Generate test summary
        if: always()
        run: |
          echo "## üé≠ E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "test-results.json" ]; then
            total=$(jq '.stats.expected + .stats.unexpected + .stats.flaky + .stats.skipped' test-results.json)
            passed=$(jq '.stats.expected' test-results.json)
            failed=$(jq '.stats.unexpected' test-results.json)
            skipped=$(jq '.stats.skipped' test-results.json)
            duration=$(jq '.stats.duration / 1000 | floor' test-results.json)

            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ‚úÖ Passed | $passed |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚ùå Failed | $failed |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è≠Ô∏è Skipped | $skipped |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è±Ô∏è Duration | ${duration}s |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$failed" -gt 0 ]; then
              echo "### ‚ùå Failed Tests" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[].suites[]?.specs[]? | select(.ok == false) | "‚ùå " + .title + "\n   " + (.tests[0].results[0].error.message // "No error message" | split("\n")[0])' test-results.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Could not parse failures"
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è No test results file found" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìé [View full HTML report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

      - name: üìä Upload merged report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report-${{ github.sha }}
          path: |
            playwright-report/
            test-results.json
          retention-days: 30

  comment:
    name: üí¨ PR Comment
    needs: [deploy, e2e, e2e-report]
    if: always() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: üì• Download test results
        if: needs.e2e.result == 'failure'
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: playwright-report-${{ github.sha }}
          path: test-artifacts

      - name: üì• Download all screenshot artifacts
        if: needs.e2e.result == 'failure'
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: playwright-screenshots-*
          path: all-screenshots
          merge-multiple: true

      - name: üì§ Upload screenshots for embedding
        id: upload-screenshots
        if: needs.e2e.result == 'failure'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Find screenshot files
          if [ ! -d "all-screenshots" ]; then
            echo "screenshot_urls=" >> $GITHUB_OUTPUT
            exit 0
          fi

          SCREENSHOTS=$(find all-screenshots -name "*.png" -type f | head -6)
          if [ -z "$SCREENSHOTS" ]; then
            echo "screenshot_urls=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create a tag for this PR's screenshots
          TAG="e2e-screenshots-pr${{ github.event.pull_request.number }}-${{ github.sha }}"

          # Delete existing release if it exists (from previous runs)
          gh release delete "$TAG" --yes 2>/dev/null || true
          git push origin --delete "$TAG" 2>/dev/null || true

          # Create a new release
          gh release create "$TAG" \
            --title "E2E Screenshots - PR #${{ github.event.pull_request.number }}" \
            --notes "Automated screenshots from E2E test failures. This release will be cleaned up automatically." \
            --prerelease

          # Upload screenshots and collect URLs
          URLS=""
          for FILE in $SCREENSHOTS; do
            BASENAME=$(basename "$FILE")
            # Sanitize filename for GitHub
            SAFE_NAME=$(echo "$BASENAME" | sed 's/[^a-zA-Z0-9._-]/_/g')

            gh release upload "$TAG" "$FILE" --clobber

            # Construct the download URL
            URL="https://github.com/${{ github.repository }}/releases/download/${TAG}/${SAFE_NAME}"
            URLS="${URLS}${URL}\n"

            echo "Uploaded: $SAFE_NAME"
          done

          # Output URLs for use in comment
          echo "screenshot_urls<<EOF" >> $GITHUB_OUTPUT
          echo -e "$URLS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "release_tag=$TAG" >> $GITHUB_OUTPUT

      - name: üí¨ Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const deployUrl = '${{ needs.deploy.outputs.deployment_url }}';
            const isProduction = '${{ needs.deploy.outputs.is_production }}' === 'true';
            const e2eResult = '${{ needs.e2e.result }}';
            const sha = '${{ github.sha }}'.substring(0, 7);
            const runId = '${{ github.run_id }}';

            let e2eStatus = '‚è≥ Pending';
            let e2eDetails = '';

            if (e2eResult === 'success') {
              e2eStatus = '‚úÖ Passed';
            } else if (e2eResult === 'failure') {
              e2eStatus = '‚ùå Failed';

              // Try to parse test results for failure details
              try {
                const resultsPath = 'test-artifacts/test-results.json';
                if (fs.existsSync(resultsPath)) {
                  const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
                  const failures = [];

                  // Recursively find all failed specs
                  function findFailures(suites, filePath = '') {
                    for (const suite of suites || []) {
                      const currentPath = filePath || suite.file || '';

                      // Check specs in this suite
                      for (const spec of suite.specs || []) {
                        if (!spec.ok) {
                          const test = spec.tests?.[0];
                          const result = test?.results?.[0];
                          const error = result?.error;

                          // Get the project name (free/pro, authenticated/unauthenticated)
                          const projectName = test?.projectName || 'unknown';

                          // Extract meaningful error info
                          let errorSummary = 'Unknown error';
                          if (error?.message) {
                            // Get the assertion failure line
                            const lines = error.message.split('\n');
                            const assertionLine = lines.find(l =>
                              l.includes('expect(') ||
                              l.includes('Expected:') ||
                              l.includes('Received:') ||
                              l.includes('Locator:') ||
                              l.includes('Timeout')
                            ) || lines[0];
                            errorSummary = assertionLine.trim().substring(0, 150);
                          }

                          // Get the file name without full path
                          const fileName = currentPath.split('/').pop() || 'unknown';

                          failures.push({
                            title: spec.title,
                            file: fileName,
                            project: projectName,
                            error: errorSummary,
                            fullError: error?.message?.substring(0, 500) || ''
                          });
                        }
                      }

                      // Recurse into nested suites
                      if (suite.suites) {
                        findFailures(suite.suites, currentPath);
                      }
                    }
                  }

                  findFailures(results.suites);

                  if (failures.length > 0) {
                    // Group failures by file
                    const byFile = {};
                    for (const f of failures) {
                      if (!byFile[f.file]) byFile[f.file] = [];
                      byFile[f.file].push(f);
                    }

                    e2eDetails = `\n\n### ‚ùå Failed Tests (${failures.length} total)\n\n`;

                    // Show first 8 failures with details
                    let shown = 0;
                    for (const [file, fileFailures] of Object.entries(byFile)) {
                      if (shown >= 8) break;

                      e2eDetails += `**${file}**\n`;
                      for (const f of fileFailures.slice(0, 3)) {
                        if (shown >= 8) break;
                        e2eDetails += `- \`[${f.project}]\` ${f.title}\n`;
                        e2eDetails += `  > ${f.error}\n`;
                        shown++;
                      }
                      if (fileFailures.length > 3) {
                        e2eDetails += `  _...and ${fileFailures.length - 3} more in this file_\n`;
                      }
                      e2eDetails += '\n';
                    }

                    if (failures.length > 8) {
                      e2eDetails += `\n_...and ${failures.length - 8} more failures_\n`;
                    }

                    // Add a collapsible section with full error details
                    e2eDetails += `\n<details>\n<summary>üìã Full error details (first 5)</summary>\n\n`;
                    for (const f of failures.slice(0, 5)) {
                      e2eDetails += `#### ${f.file} - ${f.title}\n`;
                      e2eDetails += `**Project:** \`${f.project}\`\n\n`;
                      e2eDetails += '```\n' + (f.fullError || 'No error details') + '\n```\n\n';
                    }
                    e2eDetails += `</details>\n`;
                  }
                }
              } catch (e) {
                console.log('Could not parse test results:', e.message);
                e2eDetails += `\n\n_Could not parse test results: ${e.message}_\n`;
              }

              // Embed uploaded screenshots
              const screenshotUrls = `${{ steps.upload-screenshots.outputs.screenshot_urls }}`.trim().split('\n').filter(u => u);

              if (screenshotUrls.length > 0) {
                e2eDetails += `\n### üì∏ Failure Screenshots\n\n`;
                for (const url of screenshotUrls) {
                  if (url) {
                    const filename = url.split('/').pop();
                    e2eDetails += `**${filename}**\n\n`;
                    e2eDetails += `![${filename}](${url})\n\n`;
                  }
                }
              }

              // List additional screenshots if there are more
              try {
                if (fs.existsSync('all-screenshots')) {
                  const allScreenshots = [];
                  function findScreenshots(dir) {
                    const items = fs.readdirSync(dir);
                    for (const item of items) {
                      const fullPath = path.join(dir, item);
                      if (fs.statSync(fullPath).isDirectory()) {
                        findScreenshots(fullPath);
                      } else if (item.endsWith('.png')) {
                        allScreenshots.push(fullPath);
                      }
                    }
                  }
                  findScreenshots('all-screenshots');

                  if (allScreenshots.length > screenshotUrls.length) {
                    e2eDetails += `<details>\n<summary>üìÅ All screenshot files (${allScreenshots.length} total)</summary>\n\n`;
                    for (const s of allScreenshots.slice(0, 30)) {
                      const name = s.replace('all-screenshots/', '');
                      e2eDetails += `- \`${name}\`\n`;
                    }
                    if (allScreenshots.length > 30) {
                      e2eDetails += `- _...and ${allScreenshots.length - 30} more_\n`;
                    }
                    e2eDetails += `\n[Download all from artifacts](https://github.com/${{ github.repository }}/actions/runs/${runId}#artifacts)\n`;
                    e2eDetails += `</details>\n`;
                  }
                }
              } catch (e) {
                console.log('Could not list screenshots:', e.message);
              }

              e2eDetails += `\n### üîó Debug Links\n`;
              e2eDetails += `- üìä [View HTML test report](https://github.com/${{ github.repository }}/actions/runs/${runId}) (download \`playwright-report-*\` artifact)\n`;
              e2eDetails += `- üì∏ [Download screenshots](https://github.com/${{ github.repository }}/actions/runs/${runId}#artifacts)\n`;
              e2eDetails += `- üé¨ Videos are included in screenshot artifacts for failed tests\n`;
            } else if (e2eResult === 'skipped') {
              e2eStatus = '‚è≠Ô∏è Skipped';
            } else if (e2eResult === 'cancelled') {
              e2eStatus = 'üö´ Cancelled';
            }

            const tableRows = [
              '| Item | Status |',
              '|------|--------|',
              `| **Preview URL** | ${deployUrl ? '[' + deployUrl + '](' + deployUrl + ')' : '‚ùå Failed to deploy'} |`,
              `| **E2E Tests** | ${e2eStatus} |`,
              `| **Commit** | \`${sha}\` |`
            ].join('\n');

            let quickLinks = '';
            if (deployUrl) {
              quickLinks = `\n\n### üîó Quick Links\n- [Preview App](${deployUrl})\n- [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${runId})`;
            }

            const body = `## üöÄ Deployment Summary\n\n${tableRows}${quickLinks}${e2eDetails}\n\n---\n<sub>ü§ñ Updated by GitHub Actions</sub>`;

            // Find and update existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('Deployment Summary')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
