name: test

on:
  pull_request:
    types: [opened, synchronize]
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  unit-tests:
    name: ðŸ§ª Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ— Setup repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: ðŸ— Setup monorepo
        uses: ./.github/actions/setup-monorepo
        with:
          expo-token: ${{ secrets.EXPO_TOKEN }}
          rxdb-license-key: ${{ secrets.RXDB_LICENSE_KEY }}
          uniwind-auth-token: ${{ secrets.UNIWIND_AUTH_TOKEN }}

      - name: ðŸ§ª Run unit tests (all packages)
        run: |
          # Run main packages via root Jest config
          pnpm jest --ci --passWithNoTests --coverage --coverageReporters=json-summary --coverageReporters=text
          
      - name: ðŸ§ª Run query package tests
        id: query-tests
        run: |
          cd packages/query
          npx jest --config jest.config.cjs --ci --coverage --coverageReporters=json-summary --coverageReporters=text

      - name: ðŸ“Š Generate coverage summary
        id: coverage
        if: always()
        run: |
          echo "## ðŸ“Š Test Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Function to extract coverage from json-summary
          extract_coverage() {
            local file=$1
            local name=$2
            if [ -f "$file" ]; then
              local lines=$(jq -r '.total.lines.pct // 0' "$file")
              local branches=$(jq -r '.total.branches.pct // 0' "$file")
              local functions=$(jq -r '.total.functions.pct // 0' "$file")
              local statements=$(jq -r '.total.statements.pct // 0' "$file")
              echo "| $name | ${statements}% | ${branches}% | ${functions}% | ${lines}% |"
            fi
          }
          
          echo "| Package | Statements | Branches | Functions | Lines |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------------|----------|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          
          # Extract coverage from each package
          for pkg in core components database hooks utils; do
            if [ -f "packages/$pkg/coverage/coverage-summary.json" ]; then
              extract_coverage "packages/$pkg/coverage/coverage-summary.json" "@wcpos/$pkg" >> $GITHUB_STEP_SUMMARY
            fi
          done
          
          if [ -f "packages/query/coverage/coverage-summary.json" ]; then
            extract_coverage "packages/query/coverage/coverage-summary.json" "@wcpos/query" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Save coverage data for PR comment
          echo "coverage_generated=true" >> $GITHUB_OUTPUT

      - name: ðŸ“¤ Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            packages/*/coverage/
          retention-days: 7

      - name: ðŸ’¬ Comment coverage on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Read coverage summaries
            const packages = ['core', 'components', 'database', 'hooks', 'utils', 'query'];
            let coverageRows = [];
            let totalStatements = 0;
            let totalBranches = 0;
            let totalFunctions = 0;
            let totalLines = 0;
            let packageCount = 0;
            
            for (const pkg of packages) {
              const coveragePath = `packages/${pkg}/coverage/coverage-summary.json`;
              try {
                if (fs.existsSync(coveragePath)) {
                  const data = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
                  const total = data.total || {};
                  const statements = total.statements?.pct || 0;
                  const branches = total.branches?.pct || 0;
                  const functions = total.functions?.pct || 0;
                  const lines = total.lines?.pct || 0;
                  
                  // Color coding based on coverage
                  const getEmoji = (pct) => pct >= 80 ? 'ðŸŸ¢' : pct >= 60 ? 'ðŸŸ¡' : 'ðŸ”´';
                  
                  coverageRows.push(`| @wcpos/${pkg} | ${getEmoji(statements)} ${statements}% | ${getEmoji(branches)} ${branches}% | ${getEmoji(functions)} ${functions}% | ${getEmoji(lines)} ${lines}% |`);
                  
                  totalStatements += statements;
                  totalBranches += branches;
                  totalFunctions += functions;
                  totalLines += lines;
                  packageCount++;
                }
              } catch (e) {
                console.log(`Could not read coverage for ${pkg}: ${e.message}`);
              }
            }
            
            if (packageCount === 0) {
              console.log('No coverage data found');
              return;
            }
            
            // Calculate averages
            const avgStatements = (totalStatements / packageCount).toFixed(1);
            const avgBranches = (totalBranches / packageCount).toFixed(1);
            const avgFunctions = (totalFunctions / packageCount).toFixed(1);
            const avgLines = (totalLines / packageCount).toFixed(1);
            
            const getEmoji = (pct) => pct >= 80 ? 'ðŸŸ¢' : pct >= 60 ? 'ðŸŸ¡' : 'ðŸ”´';
            
            const tableHeader = [
              '| Package | Statements | Branches | Functions | Lines |',
              '|---------|------------|----------|-----------|-------|'
            ].join('\n');
            
            const avgRow = `| **Average** | ${getEmoji(avgStatements)} **${avgStatements}%** | ${getEmoji(avgBranches)} **${avgBranches}%** | ${getEmoji(avgFunctions)} **${avgFunctions}%** | ${getEmoji(avgLines)} **${avgLines}%** |`;
            
            const legend = [
              '<details>',
              '<summary>Coverage Legend</summary>',
              '',
              '- ðŸŸ¢ Good (â‰¥80%)',
              '- ðŸŸ¡ Moderate (60-79%)',
              '- ðŸ”´ Needs improvement (<60%)',
              '',
              '</details>'
            ].join('\n');
            
            const body = `## ðŸ“Š Test Coverage Report\n\n${tableHeader}\n${coverageRows.join('\n')}\n${avgRow}\n\n${legend}\n\n---\n<sub>ðŸ¤– Updated by GitHub Actions â€¢ [View full report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>`;

            // Find and update existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('Test Coverage Report')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
