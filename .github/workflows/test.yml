name: Test

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
    paths:
      - apps/**
      - packages/**
      - .github/workflows/test.yml
      - package.json
      - pnpm-lock.yaml
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    name: üßπ Lint
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false || github.ref == 'refs/heads/main'
    steps:
      - name: üèó Setup repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: üèó Setup monorepo
        uses: ./.github/actions/setup-monorepo
        with:
          expo-token: ${{ secrets.EXPO_TOKEN }}
          rxdb-license-key: ${{ secrets.RXDB_LICENSE_KEY }}
          uniwind-auth-token: ${{ secrets.UNIWIND_AUTH_TOKEN }}

      - name: üßπ Run ESLint
        run: pnpm lint

      - name: üîç Typecheck
        run: pnpm typecheck

  unit-tests:
    name: üß™ Unit Tests
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: üèó Setup repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: üèó Setup monorepo
        uses: ./.github/actions/setup-monorepo
        with:
          expo-token: ${{ secrets.EXPO_TOKEN }}
          rxdb-license-key: ${{ secrets.RXDB_LICENSE_KEY }}
          uniwind-auth-token: ${{ secrets.UNIWIND_AUTH_TOKEN }}

      - name: üß™ Run tests for each package
        run: |
          # Track failures but continue to generate coverage for all packages
          failed=0

          # Run tests for each package separately to get individual coverage
          for pkg in core components database hooks utils; do
            echo "::group::Testing @wcpos/$pkg"
            cd packages/$pkg
            if [ -f "jest.config.js" ]; then
              npx jest --ci --passWithNoTests --coverage --coverageReporters=json-summary --coverageReporters=text --json --outputFile=test-results.json || failed=1
            fi
            cd ../..
            echo "::endgroup::"
          done

          # Run query package separately (uses .cjs config)
          echo "::group::Testing @wcpos/query"
          cd packages/query
          npx jest --config jest.config.cjs --ci --coverage --coverageReporters=json-summary --coverageReporters=text --json --outputFile=test-results.json || failed=1
          cd ../..
          echo "::endgroup::"

          # Fail the step if any tests failed
          if [ "$failed" -ne 0 ]; then
            echo "::error::One or more package tests failed"
            exit 1
          fi

      - name: üìä Generate test failure summary
        if: always()
        run: |
          # Collect test failures from JSON results
          has_failures=false
          failure_md=""

          for pkg in core components database hooks utils query; do
            file="packages/$pkg/test-results.json"
            if [ -f "$file" ]; then
              pkg_failures=$(node -e "
                const r = require('./$file');
                const failed = r.testResults.filter(t => t.status === 'failed');
                for (const f of failed) {
                  for (const a of (f.assertionResults || []).filter(a => a.status === 'failed')) {
                    const title = [...a.ancestorTitles, a.title].join(' > ');
                    const msg = (a.failureMessages || []).join('\n').substring(0, 500);
                    console.log('### \`@wcpos/$pkg\`: ' + title);
                    console.log('\`\`\`');
                    console.log(msg);
                    console.log('\`\`\`');
                    console.log('');
                  }
                }
              " 2>/dev/null || true)

              if [ -n "$pkg_failures" ]; then
                has_failures=true
                failure_md="$failure_md$pkg_failures"
              fi
            fi
          done

          if [ "$has_failures" = true ]; then
            echo "## ‚ùå Test Failures" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$failure_md" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Save for PR comment step
            mkdir -p /tmp/test-summary
            echo "$failure_md" > /tmp/test-summary/failures.md
          fi

      - name: üîí Coverage ratchet check
        if: always()
        run: |
          node -e "
            const fs = require('fs');
            const baseline = JSON.parse(fs.readFileSync('coverage-baseline.json', 'utf8'));
            const packages = Object.keys(baseline.packages);
            const metrics = ['statements', 'branches', 'functions', 'lines'];
            let failed = false;

            for (const pkg of packages) {
              const summaryPath = 'packages/' + pkg + '/coverage/coverage-summary.json';
              if (!fs.existsSync(summaryPath)) {
                console.error('@wcpos/' + pkg + ': coverage summary missing at ' + summaryPath);
                failed = true;
                continue;
              }
              const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
              const current = summary.total;
              const base = baseline.packages[pkg];

              for (const metric of metrics) {
                const currentPct = current[metric]?.pct ?? 0;
                const basePct = base[metric] ?? 0;
                if (currentPct < basePct) {
                  console.error('@wcpos/' + pkg + ': ' + metric + ' dropped from ' + basePct + '% to ' + currentPct + '%');
                  failed = true;
                }
              }
            }

            if (failed) {
              console.error('');
              console.error('Coverage ratchet failed ‚Äî coverage must not decrease.');
              console.error('If you removed code/tests intentionally, update coverage-baseline.json.');
              process.exit(1);
            } else {
              console.log('Coverage ratchet passed.');
            }
          "

      - name: üìä Generate coverage summary
        if: always()
        run: |
          echo "## üìä Test Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Statements | Branches | Functions | Lines |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------------|----------|-----------|-------|" >> $GITHUB_STEP_SUMMARY

          for pkg in core components database hooks utils query; do
            file="packages/$pkg/coverage/coverage-summary.json"
            if [ -f "$file" ]; then
              statements=$(jq -r '.total.statements.pct // 0' "$file")
              branches=$(jq -r '.total.branches.pct // 0' "$file")
              functions=$(jq -r '.total.functions.pct // 0' "$file")
              lines=$(jq -r '.total.lines.pct // 0' "$file")
              echo "| @wcpos/$pkg | ${statements}% | ${branches}% | ${functions}% | ${lines}% |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| @wcpos/$pkg | - | - | - | - |" >> $GITHUB_STEP_SUMMARY
            fi
          done

      - name: üì§ Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: packages/*/coverage/
          retention-days: 7

      - name: üí¨ Comment coverage on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const packages = ['core', 'components', 'database', 'hooks', 'utils', 'query'];
            let coverageRows = [];
            let totalStatements = 0;
            let totalBranches = 0;
            let totalFunctions = 0;
            let totalLines = 0;
            let packageCount = 0;
            
            const getEmoji = (pct) => {
              if (pct === null || pct === undefined || pct === '-') return '‚ö™';
              return pct >= 80 ? 'üü¢' : pct >= 60 ? 'üü°' : 'üî¥';
            };
            
            for (const pkg of packages) {
              const coveragePath = `packages/${pkg}/coverage/coverage-summary.json`;
              try {
                if (fs.existsSync(coveragePath)) {
                  const data = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
                  const total = data.total || {};
                  const statements = total.statements?.pct ?? 0;
                  const branches = total.branches?.pct ?? 0;
                  const functions = total.functions?.pct ?? 0;
                  const lines = total.lines?.pct ?? 0;
                  
                  coverageRows.push([
                    '|',
                    `@wcpos/${pkg}`,
                    '|',
                    `${getEmoji(statements)} ${statements.toFixed(1)}%`,
                    '|',
                    `${getEmoji(branches)} ${branches.toFixed(1)}%`,
                    '|',
                    `${getEmoji(functions)} ${functions.toFixed(1)}%`,
                    '|',
                    `${getEmoji(lines)} ${lines.toFixed(1)}%`,
                    '|'
                  ].join(' '));
                  
                  totalStatements += statements;
                  totalBranches += branches;
                  totalFunctions += functions;
                  totalLines += lines;
                  packageCount++;
                } else {
                  coverageRows.push(`| @wcpos/${pkg} | ‚ö™ No tests | ‚ö™ - | ‚ö™ - | ‚ö™ - |`);
                }
              } catch (e) {
                console.log(`Error reading coverage for ${pkg}: ${e.message}`);
                coverageRows.push(`| @wcpos/${pkg} | ‚ö™ Error | ‚ö™ - | ‚ö™ - | ‚ö™ - |`);
              }
            }
            
            // Calculate averages
            let avgRow = '| **Average** | ‚ö™ - | ‚ö™ - | ‚ö™ - | ‚ö™ - |';
            if (packageCount > 0) {
              const avgStatements = (totalStatements / packageCount).toFixed(1);
              const avgBranches = (totalBranches / packageCount).toFixed(1);
              const avgFunctions = (totalFunctions / packageCount).toFixed(1);
              const avgLines = (totalLines / packageCount).toFixed(1);
              avgRow = [
                '|',
                '**Average**',
                '|',
                `${getEmoji(avgStatements)} **${avgStatements}%**`,
                '|',
                `${getEmoji(avgBranches)} **${avgBranches}%**`,
                '|',
                `${getEmoji(avgFunctions)} **${avgFunctions}%**`,
                '|',
                `${getEmoji(avgLines)} **${avgLines}%**`,
                '|'
              ].join(' ');
            }
            
            const tableHeader = '| Package | Statements | Branches | Functions | Lines |\n|---------|------------|----------|-----------|-------|';
            const legend = '<details>\n<summary>Coverage Legend</summary>\n\n- üü¢ Good (‚â•80%)\n- üü° Moderate (60-79%)\n- üî¥ Needs improvement (<60%)\n- ‚ö™ No coverage data\n\n</details>';
            
            // Read test failure summary if it exists
            let failureSection = '';
            const failurePath = '/tmp/test-summary/failures.md';
            try {
              if (fs.existsSync(failurePath)) {
                const failures = fs.readFileSync(failurePath, 'utf8').trim();
                if (failures) {
                  failureSection = '## ‚ùå Test Failures\n\n' + failures + '\n\n';
                }
              }
            } catch (e) {
              console.log(`Error reading failures: ${e.message}`);
            }

            const body = [
              failureSection,
              '## üìä Test Coverage Report',
              '',
              tableHeader,
              coverageRows.join('\n'),
              avgRow,
              '',
              legend,
              '',
              '---',
              `<sub>ü§ñ Updated by GitHub Actions ‚Ä¢ [View full report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>`
            ].filter(Boolean).join('\n');

            // Find and update existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('Test Coverage Report')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
