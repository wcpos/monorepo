---
description: React, TypeScript, and Logging conventions for WooCommerce POS
globs: "**/*.{ts,tsx}"
alwaysApply: false
---

# React & TypeScript Conventions

## 1. Import Style & Hooks
- **Namespace Imports**: Always use namespace imports for React hooks (e.g., `React.useState`).
- **Hook Usage**: Access hooks via the React namespace rather than destructuring imports.

**✅ Good**
```typescript
const [items, setItems] = React.useState([]);
const ref = React.useRef(null);
```

**❌ Avoid**
```typescript
import { useState, useRef } from 'react';
```

## 2. The "useEffect" Rule of Merit
`useEffect` is a last resort. Before using it, verify:
- **Derived State**: Can this be calculated during render?
- **Event Handlers**: Can this be triggered by a user action?
- **External Stores**: Use specialized patterns (React Query, RxJS).
- **Justification**: If used, you MUST add a comment explaining WHY it is necessary.

### Common Anti-Pattern: useEffect to React to State You Just Set
**NEVER** use `useEffect` to perform side effects in response to state changes when you control when that state changes. Handle it directly in the event handler.

**❌ Bad** - Using useEffect to react to state you control:
```typescript
const [isOpen, setIsOpen] = React.useState(false);
React.useEffect(() => {
  if (isOpen) {
    doSomething(); // Anti-pattern: reacting to state change
  }
}, [isOpen]);
return <Popover open={isOpen} onOpenChange={setIsOpen} />;
```

**✅ Good** - Handle side effects directly in the callback:
```typescript
const [isOpen, setIsOpen] = React.useState(false);
const handleOpenChange = (open: boolean) => {
  setIsOpen(open);
  if (open) {
    doSomething(); // Direct: action at the event source
  }
};
return <Popover open={isOpen} onOpenChange={handleOpenChange} />;
```

### Mount-Only Effects Must Use Empty Dependencies
Effects intended to run **once on mount** (e.g., initial focus, scroll-to-top, select-all) must use `[]` as the dependency array. Never use a prop or derived value as a dependency when the intent is "run once."

A changing dependency turns a mount effect into a recurring side effect, which can silently break user input (e.g., re-selecting all text mid-typing, resetting scroll position, re-triggering focus).

**❌ Bad** - Dependency causes effect to re-fire on every value change:
```typescript
// Intent: select all text when the input mounts
React.useEffect(() => {
  inputRef.current?.setSelectionRange(0, props.value?.length || 100);
}, [props.value?.length]); // Re-fires whenever length changes!
```

**✅ Good** - Empty deps for a true mount effect:
```typescript
// Select all text on mount only
React.useEffect(() => {
  inputRef.current?.setSelectionRange(0, 100);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

If you need to reference a value inside the effect but don't want it to re-trigger, use a ref:
```typescript
const latestValue = React.useRef(props.value);
latestValue.current = props.value;

React.useEffect(() => {
  inputRef.current?.setSelectionRange(0, latestValue.current?.length || 100);
}, []);
```

## 3. Logging Protocol
- **NO console.log**: Use the logger library exclusively.
- **Library**: `import { log } from '@wcpos/utils/logger'`
- **Methods**: `log.debug()`, `log.info()`, `log.warn()`, `log.error()`, `log.success()`.

## 4. TypeScript & Architecture
- **No 'any'**: Use strict types and generics.
- **Platform Files**: Respect `.web.ts`, `.electron.ts`, and `.ts` (Native) resolution.

## 5. Logger Quick Reference
```typescript
import { log } from '@wcpos/utils/logger';
import { ERROR_CODES } from '@wcpos/utils/logger/error-codes';

log.debug('Debug msg', { context: { data } });
log.error('Error msg', { 
  showToast: true, 
  context: { errorCode: ERROR_CODES.TRANSACTION_FAILED } 
});
```